[{"title":"2分钟了解一下 css 选择器 nth-of-type","date":"2018-05-22T15:02:08.000Z","path":"2018/05/22/nth-of-type/","text":"今天来看下 nth-of-type 的用法 一些中文网站的解释： :nth-of-type(n)选择器匹配同类型中的第n个同级兄弟元素。 如果还是不明白建议自己查看相关资料。。 emmmm..其实直白点说就是选择相同的元素，注意！是选的元素！如果是用 class 来选择会有一点点需要注意的地方！ 上图: 这里是日常操作没有问题。下面来看看飞起来的。。假设有 2秒钟 思考时间….. 上答案 囧。。。。 所以说这个 nth-of-type 选的是在这个伪类选择器的 兄弟元素里具有相同条件的元素的第几个，至于是什么样的元素就由 冒号（:）之前的选择器决定，所以说 :nth-of-type 是具有多选的功能的，与 nth-child 不一样","tags":[]},{"title":"ios webview 版本问题","date":"2017-11-24T16:08:52.000Z","path":"2017/11/25/关于ios的webview/","text":"ios 8.0 之后 原来的UIWebView 框架将不再维护，并且启用新的 WKWebView 来加载 H5 页面，该框架的行为和交互方式更接近与ios原生的 safari 。.","tags":[]},{"title":"dom 事件对象的碎知识","date":"2017-10-16T14:12:31.000Z","path":"2017/10/16/dom-evet/","text":"一些关于 DOM 的知识，之前有些很常用，但专业术语却不知道的 1、DOM 事件级别： 由于 web标准不断的更新，DOM 事件由原来的只能在HTML 元素上绑定click到现在能自定义事件，其中经历了 DOM 0 在html 上 onclick=”fn()” 或者 element.onclick=function() {}; DOM 2 增加了 element.addEventListener(‘click’, function(){}, false); DOM 3 增加了 element.addEventListener(‘keyup’, function(){}, false); 类似的还有鼠标事件 mousedown 等 这里少了 DOM 1 ，并不是因为没有 DOM1 对应标准，而是该标准没有涉及DOM 操作相关的更新。 而addEventListener 里面的第三个参数 true 表示事件在捕获阶段执行， false 表示在冒泡阶段执行 2、DOM 事件模型： 捕获向下，冒泡往上; DOM 事件流： 捕获阶段 –&gt; 目标阶段 –&gt; 冒泡阶段; 3、DOM 捕获的具体阶段： window –&gt; document –&gt; html(document.documentElemnt) –&gt; body(document.body) –&gt;元素; 4、Event 对象的常用 API： event.preventDefault(); 这个方法神奇了，原本是用来阻止元素的默认行为，如 a 标签的链接转跳。 在移动端 ！注意移动端！！它可以在 touchstart 事件里使用，从而阻止了 touchstart 后面的 touchmove 和 touchend 事件的触发，click也会被忽略。 这个功能像 textarea 标签在readonly 属性为true时候，ios 的Safari 里点击是会触发一个缺少键盘的底部弹框，这个时候只要在touchstart 里加上这个方法就可以避免这个情况了。 还有 touchmove 里调用这个方法也可以阻止浏览器的默认滚动事件 event.stopPropagation(); 防止冒泡了，不解释 event.stopImmediatePropagation(); 元素里面如果同时注册了两个click 事件，那么在 A 方法里调用这个方法可以阻止 B 方法的执行; event.currentTarget; 当前触发事件的元素，适用场景： 事件委托中，即需要有for 循环中给每个子元素绑定事件 通过冒泡基础，给父元素绑定一次事件就能获取到所有子元素的事件触发 event.target. 此时 event.currentTarget 就是父级元素了 5、 自定义事件： Event 类 123var eve = new Event('custome');ele.addEventListener('custome', function()&#123;&#125;);ele.dispatchEvent(eve); CustomEvent 类 123456789101112var myEvent = new CustomEvent(\"userLogin\", &#123; detail: &#123; username: \"davidwalsh\" &#125;, bubbles: true, // 事件是否冒泡 cancelable: false // 是否可以取消事件的默认行为&#125;);element.addEventListener(\"userLogin\", function(e) &#123; console.info(\"Event is: \", e); console.info(\"Custom data is: \", e.detail);&#125;);element.dispatchEvent(myEvent); 两个类区别在于 CustomEvent 在自定义事件时候可以传值，能指定是否冒泡和 能否取消默认行为;","tags":[]},{"title":"块级格式化上下文 （BFC）","date":"2017-09-10T12:57:25.000Z","path":"2017/09/10/bfc/","text":"来认识一下 BFCBFC 英文是Block Formatting Context，中文直译为块级格式上下文 渲染规则 ： 1、在bfc 元素垂直方向的边距不会发生重叠。 2、bfc 的边距不会与浮动元素发生重叠（清除浮动原理） 3、bfc 在页面上是个独立的容器，外面和里面的元素互不影响 4、计算bfc 元素高度的时候，里面的浮动元素也会参与计算 创建bfc： 1、float 不为none 2、position 不为 static inherit 3、display属性为 table-cell 系列 4、overflow 通常有以下情况需要用到 BFC 来解决问题的： 1、垂直方向元素边距重叠了 效果如下： 兄弟元素之间的margin 重叠了然后取最大值，这个时候如果给其中一个变成BFC就可以阻止这各元素的重叠问题。 2、与float元素区域重叠了 这个时候给float 元素创建 BFC 就可以让float 元素的区域不会被其他元素影响了 3、就是需要计算float元素高度的 时候，给外层盒子创建BFC（清除浮动的原理~）","tags":[]},{"title":"关于三栏布局（水平）各种方式及优缺点","date":"2017-08-21T02:53:42.000Z","path":"2017/08/21/layout/","text":"今天来列举一下三栏布局 常见的三栏布局都是左右宽度固定、中间自适应的。 像这样： 然后我们先来假设最小高度是已知的so 先写好通用样式，比如左边是骚黄，中间自适应，右边蓝色等等123456789101112131415161718192021&lt;style type=\"text/css\"&gt; html *&#123; margin: 0; padding: 0; &#125; .layout&#123; margin-top: 20px; &#125; .layout .left, .layout .center, .layout .right&#123; min-height: 100px; &#125; .layout .left&#123; background-color: yellow; &#125; .layout .right&#123; background-color: #4AA8D8; &#125; .layout .center&#123; background-color: #ff5722; &#125;;&lt;/style&gt; 然后是 浮动的 方式来试一下12345678910111213141516171819202122232425&lt;section class=\"layout float\"&gt; &lt;style media=\"screen\"&gt; .layout.float&#123; min-height: 100px; &#125; .layout.float .left&#123; float: left; width: 100px; &#125; .layout.float .right&#123; float: right; width: 100px; &#125; &lt;/style&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;article class=\"center\"&gt; &lt;h1&gt;我是浮动的解决方案哟~~&lt;/h1&gt; &lt;div class=\"desc\"&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 噢~ 浮动的不要太简单毕竟是老牌方法，优点就是兼容性好缺点：需要清除浮动，否则对其他兄弟元素有影响、脱离文档流，当然还有一些惊悚的情况比如。。 嗯嗯这就是大名鼎鼎的文本围绕效果。如果要消除这个效果（或者说清除浮动带来的影响）就要创建BFC ，什么？你说不知道BFC是啥？你说来我们谈谈。 BFC 英文是Block Formatting Context，中文直译为块级格式上下文。简单来讲就是一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 然后是定位的123456789101112131415161718192021222324252627282930313233&lt;section class=\"layout position\"&gt; &lt;style media=\"screen\"&gt; .layout.position&#123; position: relative; min-height: 120px; &#125; .layout.position .left&#123; position: absolute; left: 0; width: 100px; &#125; .layout.position .right&#123; position: absolute; right: 0; width: 100px; &#125; .layout.position .center&#123; position: absolute; left: 100px; right: 100px; &#125; &lt;/style&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;article class=\"center\"&gt; &lt;h1&gt;我是定位的解决方案哟~~&lt;/h1&gt; &lt;div class=\"desc\"&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 可以看出来定位的方法挺好用的，兼容性好还很灵活，想在哪就在哪，配合js还可以写动效啥的。bug~ 缺点也很明显，因为脱离了文档流，一旦用了定位，下面所有的子元素都要用定位才能做了。 然后是flexbox1234567891011121314151617181920212223242526&lt;section class=\"layout flex\"&gt; &lt;style media=\"screen\"&gt; .layout.flex&#123; display: flex; &#125; .layout.flex .left&#123; width: 100px; &#125; .layout.flex .right&#123; width: 100px; &#125; .layout.flex .center&#123; flex: 1; &#125; &lt;/style&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;article class=\"center\"&gt; &lt;h1&gt;我是flexbox的解决方案哟~~&lt;/h1&gt; &lt;div class=\"desc\"&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;/div&gt; &lt;/article&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/section&gt; suguoyi~ flex 方法的代码量简直完爆上面两种，不存在对其他兄弟元素的影响不需要每个子元素都特别设置毕竟flex 布局就是为了解决以上两种方法带来问题而生的，so兼容性是他的shortcoming 要不用table试一下吧？1234567891011121314151617181920212223242526&lt;section class=\"layout table\"&gt; &lt;style media=\"screen\"&gt; .layout.table&#123; display: table; width:100%; min-height: 100px; &#125; .layout.table .left, .layout.table .right&#123; width: 100px; display: table-cell; &#125; .layout.table .center&#123; display: table-cell; &#125; &lt;/style&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;article class=\"center\"&gt; &lt;h1&gt;我是table的解决方案哟~~&lt;/h1&gt; &lt;div class=\"desc\"&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;/div&gt; &lt;/article&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/section&gt; 放下你对table 的偏见，其实table 布局并不是一无是处的，比如这个三栏布局比起浮动简直不要方便太多1、兼容性好，无副作用2、同高而且高度自适应的横排布局、类表格布局都能轻松实现 再来个 grid 的123456789101112131415161718&lt;section class=\"layout grid\"&gt; &lt;style media=\"screen\"&gt; .layout.grid&#123; display:grid; grid-template-columns: 100px auto 100px; &#125; &lt;/style&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;article class=\"center\"&gt; &lt;h1&gt;我是 grid 的解决方案哟~~&lt;/h1&gt; &lt;div class=\"desc\"&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;p&gt;内容内容内容内容&lt;/p&gt; &lt;/div&gt; &lt;/article&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/section&gt; 这。。grid 真的是让你的 css 在布局上，为所欲为！！简单粗暴: 设置父元素为 grid ，然后制定子元素块 或者 以网格线来自定义宽或高缺点嘛，当然是支不支持的问题了，IE10 都不支持啊。。 其他的想到在写了最后，还有个已知最小高度的情况。如果我们把内容增加，而不手动改其他代码看会是啥情况咯。 阔以看到，最小高度的情况下 ，如果把内容增加，依然能用不鬼畜的有 flexbox 和 table 布局恭喜两位获奖者，我们的工作人员将会在下辈子之前通知你来领取奖品~~~end","tags":[]},{"title":"画了一个圆饼图~","date":"2017-01-11T06:49:09.000Z","path":"2017/01/11/canvas/","text":"用canvas 画了一个圆饼图。。 根据同圆心，外面圆颜色和半径可配置 如图 链接","tags":[{"name":"杂","slug":"杂","permalink":"http://ouxiaohui.github.io/tags/杂/"}]},{"title":"移动开发Html5前端性能优化小记","date":"2017-01-05T03:35:50.000Z","path":"2017/01/05/优化笔记/","text":"整理过的页面优化注意项：加载优化 1.加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点。 减少HTTP请求因为手机浏览器同时响应请求为4个请求(Android支持4个，iOS 5后可支持6个)，所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个。 1.合并CSS、JavaScript 2.合并小图片，使用雪碧图 缓存使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache(长Cache资源的更新可使用时间戳) 1.缓存一切可缓存的资源 2.使用长Cache（使用时间戳更新Cache） 3.使用外联式引用CSS、JavaScript 无阻塞 1.写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾部或使用异步方式加载。 2.使用首屏加载 想了解首屏加载的猛戳我! 按需加载将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量。 1.LazyLoad 2.滚屏加载 3.通过Media Query选择性加载css 预加载大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失。对用户行为分析，可以在当前页加载下一页资源，提升速度。 1.可感知Loading(如进入空间游戏的Loading) 2.不可感知的Loading（如提前加载下一页) 压缩图片图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示。 1.使用其它方式代替图片(1. 使用CSS3 2. 使用SVG 3. 使用IconFont) 2.选择合适的大小（首次加载不大于1014KB 且 不宽于640（基于手机屏幕一般宽度) 异步加载第三方资源 1.第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源。 减少重绘和回流 1.避免不必要的Dom操作 2.尽量改变Class而不是Style 3.避免使用document.write TOUCH事件优化 1.使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作 动画优化 1.尽量使用CSS3动画 1.CSS动画只用 (-webkit- 无前缀)两种即可","tags":[{"name":"笔记","slug":"笔记","permalink":"http://ouxiaohui.github.io/tags/笔记/"}]},{"title":"defer & async 属性 的作用和区别","date":"2016-10-03T03:12:02.000Z","path":"2016/10/03/defer-async/","text":"在script标签中，可以添加两个属性 defer &amp; async，现在来试一下这里两个属性的作用和区别script标签的使用分为三种情况： 1.&lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt; 没有defer或async属性，浏览器会立即加载并执行相应的脚本。也就是说在渲染script标签之后的文档之前，不等待后续加载的文档元素，读到就开始加载和执行，此举会阻塞后续文档的加载； 2.&lt;script async src=&quot;example.js&quot;&gt;&lt;/script&gt; 有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行； 3.&lt;script defer src=&quot;example.js&quot;&gt;&lt;/script&gt; 有了defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本的执行需要等到文档有元素解析完成之后，DOMContentLoaded事件触发执行之前。 那么来总结一下： 1.defer和async在网络加载过程是一致的，都是异步执行的； 2.两者的区别在于脚本加载完成之后何时执行，可以看出defer更符合大多数场景对应用脚本加载和执行的要求； 3.如果存在多个有defer属性的脚本，那么它们是按照加载顺序执行脚本的；而对于async，它的加载和执行是紧紧挨着的，无论声明顺序如何，只要加载完成就立刻执行，它对于应用脚本用处不大，因为它完全不考虑依赖。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://ouxiaohui.github.io/tags/笔记/"}]}]